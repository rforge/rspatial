\documentclass{article}
% \VignetteIndexEntry{sp: classes and methods for spatial data}

\usepackage{graphicx}
\usepackage{hyperref}

\usepackage{color}

\usepackage{Sweave}

\title{ S Classes and methods for spatial data:\\
the {\tt sp} package }
\author{Edzer J.\ Pebesma\footnote{Dept of Physical Geography,
Faculty of Geosciences, Utrecht University, P.O. Box 80.115,
3508 TC Utrecht, The Netherlands {\tt e.pebesma@geog.uu.nl}} \and 
Roger S.\ Bivand\footnote{Economic Geography Section, Department of Economics, %
Norwegian School of Economics and Business Administration, %
Breiviksveien 40, N-5045 Bergen, Norway; {\tt Roger.Bivand@nhh.no}}}
\date{Feb 2005}

\begin{document}

\maketitle

\section{Introduction}

The {\tt sp} package provides classes and methods for dealing with spatial
data in S (R and S-Plus). We have chosen to use S4 classes and methods
style (as described in ``Programming with Data'' by John Chambers) to
allow validation of objects created. Although we mainly aim at using
spatial data in the geographical (two-dimensional) domain, those data
structures that have straightforward implementations in higher dimensions
(points, grids) do allow this.

The motivation to write this package was born on a
\href{http://spatial.nhh.no/meetings/vienna/index.html}{pre-conference
spatial data workshop} during
\href{http://www.ci.tuwien.ac.at/Conferences/DSC-2003/}{DSC 2003}.
At that time, the advantage of having multiple R packages for spatial
statistics seemed to be blocked by the lack of a uniform interface
for handling spatial data. Each package had its own conventions on how
spatial data were stored and returned.

With this package we hope that many maintainers of packages dealing with
spatial data will either convert their package to supporting the spatial
data classes provided here, or make their package compatible with these
classes. Even if only conversion routines to and from {\tt sp} classes
become available it would be useful, as one-to-many conversions are much
easier to deal with than many-to-many.

This vignette describes the classes, methods and functions provided
by sp. Instead of manipulating the class slots (components) directly,
we provide methods and functions to create the classes from elementary
types such as matrices, data.frames or lists and to convert them back
to any of these types. Also, coercion (type casting) from one class to
the other is provided, where relevant.

Package {\tt sp} is started by the command
<<echo=TRUE,print=FALSE>>= 
library(sp)
@

<<echo=FALSE,print=FALSE>>= 
set.seed(13331)
library(lattice)
@

\section{Spatial data classes}

The spatial data are points, grids, lines, rings and polygons. Package
{\tt sp} provides classes for the spatial-only information (the topology),
e.g. {\tt SpatialPoints}, and extensions for the case where we attribute
information stored in a {\tt data.frame} is available for each point,
e.g. {\tt SpatialPointsDataFrame}. The available data classes are:

\begin{center}
\begin{tabular}{lllll}
data type & class                        & attributes? & contains \\ \hline
points    & {\tt SpatialPoints}          & No          &{\tt Spatial}* \\
points    & {\tt SpatialPointsDataFrame} & Yes         &{\tt SpatialPoints}* \\
grid      & {\tt SpatialGrid  }          & No          &{\tt SpatialPoints}* \\
grid      & {\tt SpatialGridDataFrame}   & Yes         &{\tt SpatialGrid}* \\
          &                              &             &{\tt SpatialPointsDataFrame}** \\
line      & {\tt SLine}                  & No          &{\tt Spatial}* \\
lines     & {\tt SLines}                 & No          &{\tt Spatial}*, {\tt Sline} list \\
lines     & {\tt SpatialLines}           & No          &{\tt Spatial}*, {\tt SLines} list \\
lines     & {\tt SpatialLinesDataFrame}  & Yes         &{\tt SpatialLines}* \\
rings     & {\tt Sring}                  & No          &{\tt SLine}* \\
rings     & {\tt Srings}                 & No          &{\tt Spatial}*, {\tt Sring} list \\
rings     & {\tt SpatialRings}           & No          &{\tt Spatial}*, {\tt Srings} list \\
rings     & {\tt SpatialRingsDataFrame}  & Yes         &{\tt SpatialRings}* \\
\end{tabular}
\end{center}
* by direct extension; ** by setIs() relationship; otherwise: contains
a list of objects of the class metioned under ``contains''.

The class {\tt Spatial} does not exist to hold actual data, it only
provides the information common to all derived classes: a bounding
box and information about the coordinate reference system (geographic
projection information).

In the following sections we will show how we can create objects of
these classes from scratch or from other classes, and which methods and
functions are available for them.

\section{Points}

\subsection{{\tt SpatialPoints} without attributes}

We can generate a set of 10 points on the unit square $[0,1] \times
[0,1]$ by
<<echo=TRUE,print=FALSE>>= 
xc = round(runif(10), 2)
yc = round(runif(10), 2)
xy = cbind(xc, yc)
xy
@
this $10 \times 2$ matrix can be converted into a {\tt SpatialPoints}
object by

<<echo=TRUE,print=FALSE,fig=FALSE>>= 
xy.sp = SpatialPoints(xy)
xy.sp
plot(xy.sp, pch = 2)
@
The plot is shown in figure \ref{fig:points}.

\begin{figure}
\begin{center}
<<echo=FALSE,print=FALSE,fig=TRUE>>= 
plot(xy.sp, pch = 2)
@
\end{center}
\caption{plot of {\tt SpatialPoints} object; aspect ratio of x and y axis units is 1}
\label{fig:points}
\end{figure}

We can retrieve the coordinates from {\tt xy.sp} by
<<echo=TRUE>>=
xy.cc = coordinates(xy.sp)
class(xy.cc)
dim(xy.cc)
@
and other methods retrieve the bounding box, the dimensions, select points
(not dimensions or columns), coerce to a data.frame, or print a summary:
<<echo=TRUE>>=
bbox(xy.sp)
dimensions(xy.sp)
xy.sp[1:2] # note that row 1 and 2 are selected!
xy.df = as.data.frame(xy.sp)
class(xy.df)
dim(xy.df)
summary(xy.sp)
@

\subsection{{\tt SpatialPoints} with attributes: {\tt SpatialPointsDataFrame}}

One way of creating a {\tt SpatialPointsDataFrame} object is by combining
a {\tt SpatialPoints} object with a data.frame containing the attributes:
<<echo=TRUE>>=
df = data.frame(z1 = round(5 + rnorm(10), 2), z2 = 20:29)
df
xy.spdf = SpatialPointsDataFrame(xy.sp, df)
xy.spdf
summary(xy.spdf)
dimensions(xy.spdf)
xy.spdf[1:2, ] # selects row 1 and 2
xy.spdf[1] # selects attribute column 1, along with the coordinates
xy.spdf[1:2, "z2"] # select row 1,2 and attribute "z2"
xy.df = as.data.frame(xy.spdf)
xy.df[1:2,]
xy.cc = coordinates(xy.spdf)
class(xy.cc)
dim(xy.cc)
@
A note on selection with \verb|[|: the behaviour is as much as possible
copied from that of data.frames, but coordinates are always sticky and a
{\tt SpatialPointsDataFrame} is always returned; {\tt drop=FALSE} is not
allowed. If coordinates should be dropped, use the {\tt as.data.frame}
method and select the non-coordinate data, or use \verb|[[| (example
below).

{\tt SpatialPointsDataFrame} objects can be created directly from 
data.frames by specifying which columns contain the coordinates:
<<echo=TRUE>>=
df1 = data.frame(xy, df)
coordinates(df1) = c("xc", "yc")
df1
@
or
<<echo=TRUE>>=
df2 = data.frame(xy, df)
coordinates(df2) = ~xc+yc
df2[1:2,]
as.data.frame(df2)[1:2,]
@
Note that in this form, {\tt coordinates} by setting (specifying) the
coordinates promotes it argument, an object of class {\tt data.frame}
to an object of class {\tt SpatialPointsDataFrame}. The method {\tt
as.data.frame} coerces back to the original {\tt data.frame}. When used
on a right-hand side of an equation, {\tt coorinates} {\em retrieves}
the matrix with coordinates:
<<>>=
coordinates(df2)[1:2,]
@
Elements (columns) in the data.frame part of an object can be manipulated
(retrieved, assigned) directly:
<<>>=
df2[["z2"]]
df2[["z2"]][10] = 20
df2[["z3"]] = 1:10
summary(df2)
@
Plotting attribute data can be done by using either {\tt cplot} to
colour symbols, or {\tt bubble} which uses symbol size:
<<eval=FALSE,echo=TRUE,print=FALSE>>=
bubble(df2, "z1", key.space = "bottom")
cplot(df2, "z1", key.space = "bottom")
@
the resulting plots are shown in figure \ref{fig:spdf}.

\begin{figure}
\begin{center}
<<echo=FALSE,print=FALSE,fig=TRUE>>= 
print(bubble(df2, "z1", key.space = "bottom"), split = c(1,1,2,1), more=TRUE)
print(cplot(df2, "z1", key.space = "bottom"), split =  c(2,1,2,1), more=FALSE)
@
\end{center}
\caption{plot of {\tt SpatialPointsDataFrame} object, using symbol 
size ({\tt bubble}, top) or colour ({\tt cplot}, bottom) }
\label{fig:spdf}
\end{figure}

\section{Grids}
\subsection{Creating grids from topology}
When we know the offset, the cell sizes and the dimensions of a grid, we
can specify this by using the function {\tt GridTopology}:
<<>>=
gt = GridTopology(cellcentre.offset = c(1,1,2), cellsize=c(1,1,1), cells.dim = c(3,4,6))
grd = SpatialGrid(grid = gt)
summary(grd)
@

The grid parameters can be retrieved by the function
<<>>=
gridparameters(grd)
@

\subsection{Creating grids from points}
In the following example a three-dimensional grid is constructed from
a set of point coordinates:
<<>>=
pts = expand.grid(x = 1:3, y = 1:4, z=2:7)
grd.pts = SpatialGrid(points = SpatialPoints(pts))
summary(grd.pts)
@
Note that when passed a points argument, SpatialGrid also accepts a
tolerance (default 10 * .Machine\$double.eps) to specify how exactly
the points should be on a grid. For very large coordinates, this value
may have to be increased.

\subsection{Gridded data with attributes}

Spatial, gridded data are data with coordinates on a regular lattice.
To form such a grid we can go from coordinates:
<<>>=
attr = expand.grid(xc = 1:3, yc = 1:3)
grd.attr = data.frame(attr, z = 1:9)
coordinates(grd.attr) = ~xc + yc
gridded(grd.attr)
gridded(grd.attr) = TRUE
gridded(grd.attr)
summary(grd.attr)
@

\subsection{Are grids stored as points or as matrix/array?}
Objects of class {\tt SpatialGridDataFrame} are stored in of the
two forms:
\begin{enumerate}
\item {\em cell form}: grid cells stored as points, like a {\tt
SpatialPointsDataFrame}, but extended with grid parameters
\item {\em full grid form}: as a matrix (or array) containing the
attribute values, without coordinates: coordinates can be derived from
row/column in the matrix/array and grid parameters.
\end{enumerate}
The form in which a {\tt SpatialGridDataFrame} comes depends on whether
the grid was created from a set of points or from a matrix or external
grid format (e.g. read through rgdal). Retrieving the form, or conversion
to another form is provided by the function {\tt fullgrid}:
<<>>=
fullgrid(grd)
fullgrid(grd.pts)
fullgrid(grd.attr)
fullgrid(grd.pts) = TRUE
fullgrid(grd.attr) = TRUE
fullgrid(grd.pts)
fullgrid(grd.attr)
@

The advantage of having grids in cell form is that when a large part
of the grid contains missing values, these cells do not have to be
stored; also, no ordering of grid cells is required. For plotting by
{\tt gridplot}, a front-end to {\tt levelplot}, this form is required; in
contrast, {\tt image} requires a slightly altered version of the the full
grid form.  A disadvantage of the cell form is that the coordinates for
each point have to be stored, which may be prohibitive for large grids.
Grids in cell form have an index stored which allows fast transformation
to the full grid form.

Besides {\tt print}, {\tt summary}, {\tt plot},
objects of class {\tt SpatialGridDataFrame} have methods for
\begin{itemize}
\item \verb|[| select rows (points) or columns (variables)
\item \verb|[[| retrieve a column from the attribute table (data.frame part)
\item \verb|[[<-| assign or replace a column in the attribute table (data.frame part)
\item {\tt coordinates} retrieve the coordinates of grid cells
\item {\tt as.matrix} retrieve the data as a matrix. The first index (rows) is the
x-column, the second index (columns) the y-coordinate. Row index 1 is the smallest
x-coordinate; column index 1 is the larges y-coordinate (top-to-bottom).
\item {\tt as} coercion methods for {\tt data.frame}, {\tt SpatialPointsDataFrame}
\item{\tt image} plot an image of the grid
\end{itemize}
Finally, {\tt gridplot}, a front-end to {\tt levelplot} allows the
plotting of a single grid plot or a lattice of grid plots.

\section{Lines}

\subsection{Building line objects from scratch}
In many instances, line coordinates will be retrieved from external
sources.  The following example shows how to build an object of class
{\tt SpatialLines} from scratch.

% build line objects
<<fig=TRUE>>=
l1 = cbind(c(1,2,3),c(3,2,2))
l1a = cbind(l1[,1]+.05,l1[,2]+.05)
l2 = cbind(c(1,2,3),c(1,1.5,1))
Sl1 = Sline(l1)
Sl1a = Sline(l1a)
Sl2 = Sline(l2)
S1 = Slines(list(Sl1, Sl1a))
S2 = Slines(list(Sl2))
Sl = SpatialLines(list(S1,S2))
summary(Sl)
plot(Sl, col = c("red", "blue"))
@

\subsection{Building line objects with attributes}

The class {\tt SpatialLinesDataFrame} is designed for holding
lines data that have an attribute table (data.frame) attached
to it:
<<>>=
df = data.frame(z = c(1,2))
Sldf = SpatialLinesDataFrame(Sl, data = df)
summary(Sldf)
@
Not many useful methods for it are available yet.  The {\tt plot} method
only plots the lines, ignoring attribute table values. Suggestions for
useful methods are welcome.

\section{Polygons}

\section{Building from scratch}
The following example shows how a set of polygons are built from scratch.
Note that {\tt Sr4} has the opposite direction (right) as the other three;
it is meant to represent a hole in the {\tt Sr3} polygon.
<<fig=TRUE>>=
Sr1 = Sring(cbind(c(2,4,4,1,2),c(2,3,5,4,2)))
Sr2 = Sring(cbind(c(5,4,2,5),c(2,3,2,2)))
Sr3 = Sring(cbind(c(4,4,5,10,4),c(5,3,2,5,5)))
Sr4 = Sring(cbind(c(5,6,6,5,5),c(4,4,3,3,4)))

Srs1 = Srings(list(Sr1), "s1")
Srs2 = Srings(list(Sr2), "s2")
Srs3 = Srings(list(Sr3, Sr4), "s3/4")
SR = SpatialRings(list(Srs1,Srs2,Srs3), 1:3)
plotSpatialRings(SR)
# plot(SR)
@

\section{Interfaces to GIS and external formats}

\subsection{Reading grids through rgdal}
<<fig=TRUE>>=
library(rgdal)
x <- read.gdal(system.file("external/test.ag", package="sp")[1])
class(x)
#x=x[x[["band1"]] < 1e30, ] 
print(summary(x))
image(x)
y = read.gdal(system.file("pictures/Rlogo.jpg", package = "rgdal")[1])
summary(y)
gridplot(y, zcol=1:3, names.attr=c("red","green","blue"), col.regions=grey(0:100/100),
    main="example of three-layer (RGB) raster image", as.table=TRUE)
@

<<echo=FALSE,fig=TRUE>>=
print(gridplot(y, zcol=1:3, names.attr=c("red","green","blue"), col.regions=grey(0:100/100),
    main="example of three-layer (RGB) raster image", as.table=TRUE))
@

\subsection{Reading ESRI shapefiles}
points, lines, polygons?
\subsection{Reading ArcGIS coverages}

\end{document}

% vim:syntax=tex
